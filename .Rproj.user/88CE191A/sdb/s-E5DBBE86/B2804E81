{
    "collab_server" : "",
    "contents" : "// MIT License\n// Copyright (c) 2019 Vincent Runge\n\n#include \"Omega.h\"\n#include \"Costs.h\"\n#include \"ListPoint.h\"\n#include \"Point.h\"\n\n#include \"math.h\"\n\n#include <algorithm> // std::reverse // std::min // std::max\n#include<iostream>\n#include <stdlib.h>\n\n//####### constructor #######////####### constructor #######////####### constructor #######//\n//####### constructor #######////####### constructor #######////####### constructor #######//\n\nOmega::Omega(std::vector< double >& values, double beta, unsigned int n)\n{\n  nbStates = values.size();\n  states = new double[nbStates];\n  for(unsigned int i = 0; i < nbStates; i++){states[i] = values[i];}\n\n  ///\n  /// MATRIX INITIALIZATION\n  ///\n  Q = new double*[nbStates]; ///matrix of costs\n  lastChpt = new unsigned int*[nbStates]; ///matrix of best last changepoints\n  lastIndState = new unsigned int*[nbStates]; ///matrix of starting states for the best last segment\n\n  for(unsigned int i = 0; i < nbStates; i++){Q[i] = new double[n];}\n  for(unsigned int i = 0; i < nbStates; i++){lastChpt[i] = new unsigned int[n];}\n  for(unsigned int i = 0; i < nbStates; i++){lastIndState[i] = new unsigned int[n];}\n\n  penalty = beta;\n}\n\n\n\nOmega::~Omega()\n{\n  delete(states);\n  states = NULL;\n  for(unsigned int i = 0; i < nbStates; i++){delete(Q[i]);}\n  for(unsigned int i = 0; i < nbStates; i++){delete(lastChpt[i]);}\n  for(unsigned int i = 0; i < nbStates; i++){delete(lastIndState[i]);}\n  delete [] Q;\n  Q = NULL;\n  delete [] lastChpt;\n  lastChpt = NULL;\n  delete [] lastIndState;\n  lastIndState = NULL;\n}\n\n//####### accessors #######////####### accessors #######////####### accessors #######//\n//####### accessors #######////####### accessors #######////####### accessors #######//\n\nstd::vector< int > Omega::GetChangepoints() const {return(changepoints);}\nstd::vector< double > Omega::GetParameters() const {return(parameters);}\ndouble Omega::GetGlobalCost() const {return(globalCost);}\ndouble Omega::GetPruning() const {return(pruning);}\n\n\n//####### algo #######////####### algo #######////####### algo #######//\n//####### algo #######////####### algo #######////####### algo #######//\n//####### algo #######////####### algo #######////####### algo #######//\n//####### algo #######////####### algo #######////####### algo #######//\n//####### algo #######////####### algo #######////####### algo #######//\n\nvoid Omega::algo(std::vector< double >& data)\n{\n  unsigned int n = data.size();\n  unsigned int p = nbStates;\n\n  ///\n  /// PREPROCESSING\n  ///\n  double* S1 = new double[n];\n  double* S2 = new double[n];\n  double* SP = new double[n];\n  S1[0] = data[0];\n  S2[0] = data[0] * data[0];\n  SP[0] = data[0] ;\n  for(unsigned int i = 1; i < n; i++){S1[i] = S1[i-1] + data[i];}\n  for(unsigned int i = 1; i < n; i++){S2[i] = S2[i-1] + (data[i] * data[i]);}\n  for(unsigned int i = 1; i < n; i++){SP[i] = SP[i-1] + (i+1) * data[i];}\n\n  Costs cost;\n  ///\n  /// FILL FIRST COLUMN in Q\n  ///\n  for(unsigned int i = 0; i < p; i++)\n  {\n    Q[i][0] = (data[0] - states[i])*(data[0] - states[i]);\n    lastChpt[i][0] = 0;\n    lastIndState[i][0] = 0;\n  }\n\n  ///\n  /// ALGO\n  ///\n  double temp_Q = -1;\n  int temp_chpt = -1;\n  unsigned int temp_indState = 0;\n  unsigned int zero = 0;\n\n  ///\n  /// states u to v -> time position t to T\n  /// explore in (u,t) for fixed (v,T)\n  ///\n  for(unsigned int T = 1; T < n; T++)\n  {\n    for(unsigned int v = 0; v < p; v++)\n    {\n      /////\n      ///// EXPLORE MATRIX size p*T\n      /////\n      temp_Q = Q[0][0] + cost.slopeCost(states[0], states[v], zero, T, S1[0], S1[T], S2[0], S2[T], SP[0], SP[T]) + penalty;\n      temp_indState = 0;\n      temp_chpt = 0;\n\n      for(unsigned int t = 0; t < T; t++)\n      {\n        for(unsigned int u = 0; u < p; u++) /////explore colum of states\n        {\n          if(temp_Q > Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty)\n          {\n            temp_Q = Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty;\n            temp_indState = u;\n            temp_chpt = t;\n          }\n        }\n      }\n      /////\n      ///// Write response\n      /////\n      Q[v][T] = temp_Q;\n      lastIndState[v][T] = temp_indState;\n      lastChpt[v][T] = temp_chpt;\n    }\n  }\n\n  delete [] S1;\n  S1 = NULL;\n  delete [] S2;\n  S2 = NULL;\n  delete [] SP;\n  SP = NULL;\n}\n\n//####### algoChannel #######////####### algoChannel #######////####### algoChannel #######//\n//####### algoChannel #######////####### algoChannel #######////####### algoChannel #######//\n//####### algoChannel #######////####### algoChannel #######////####### algoChannel #######//\n//####### algoChannel #######////####### algoChannel #######////####### algoChannel #######//\n//####### algoChannel #######////####### algoChannel #######////####### algoChannel #######//\n\nvoid Omega::algoChannel(std::vector< double >& data)\n{\n  unsigned int n = data.size();\n  unsigned int p = nbStates;\n\n  ///\n  /// PREPROCESSING\n  ///\n  double* S1 = new double[n];\n  double* S2 = new double[n];\n  double* SP = new double[n];\n  S1[0] = data[0];\n  S2[0] = data[0] * data[0];\n  SP[0] = data[0] ;\n  for(unsigned int i = 1; i < n; i++){S1[i] = S1[i-1] + data[i];}\n  for(unsigned int i = 1; i < n; i++){S2[i] = S2[i-1] + (data[i] * data[i]);}\n  for(unsigned int i = 1; i < n; i++){SP[i] = SP[i-1] + (i+1) * data[i];}\n\n  Costs cost;\n  ///\n  /// FILL FIRST COLUMN in Q\n  ///\n  for(unsigned int i = 0; i < p; i++)\n  {\n    Q[i][0] = (data[0] - states[i])*(data[0] - states[i]);\n    lastIndState[i][0] = 0;\n    lastChpt[i][0] = 0;\n  }\n\n  ///\n  /// ALGO\n  ///\n  double temp_Q = -1;\n  int temp_chpt = -1;\n  unsigned int temp_indState = 0;\n\n  //////////////////////////////////////////////////\n  //////////////////////////////////////////////////\n  ///\n  /// CHANNEL INFORMATION\n  /// u1 / u2 = \"min / max\" in each column of Q\n  ///\n  unsigned int* u1 = new unsigned int[n];\n  unsigned int* u2 = new unsigned int[n];\n  unsigned int theStart;\n  unsigned int theEnd;\n  double theV = 0;\n  unsigned int indexTheV = 0;\n\n  unsigned int zero = 0;\n  ///\n  /// states u to v -> time position t to T\n  /// explore in (u,t) for fixed (v,T)\n  ///\n  for(unsigned int T = 1; T < n; T++)\n  {\n    ///\n    /// FILL u1 and u2 vectors\n    ///\n    theStart = 0;\n    while(theStart < (p - 1) && Q[theStart][T - 1] > Q[theStart + 1][T - 1]){theStart = theStart + 1;}\n    u1[T-1] = theStart;\n    theEnd = p - 1;\n    while(theEnd > 0 && Q[theEnd][T - 1] > Q[theEnd - 1][T - 1]){theEnd = theEnd - 1;}\n    u2[T-1] = theEnd;\n\n\n    for(unsigned int v = 0; v < p; v++)\n    {\n      /////\n      ///// EXPLORE MATRIX size p*T -> restricted on each column\n      /////\n      temp_indState = 0;\n      temp_chpt = 0;\n\n      temp_Q = Q[0][0] + cost.slopeCost(states[0], states[v], zero, T, S1[0], S1[T], S2[0], S2[T], SP[0], SP[T]) + penalty;\n\n\n      for(unsigned int t = 0; t < T; t++)\n      {\n        /////\n        ///// FIND the minimum of the cost in start state\n        /////\n        if(t < T-1){\n        theV = cost.vhat(states[v], t, T, S1[t], S1[T], SP[t], SP[T]);\n        indexTheV = cost.closestState(theV, states, p);\n        }else{indexTheV = u1[T-1];}\n\n        /// std::cout << T << \" theV \" << theV << \"  indexTheV \" << indexTheV << \"  --u1[t] \" << u1[t] << \"  u2[t] \" << u2[t] << std::endl;\n        /// explore values between min(u1[t],indexTheV) and max(u2[t],indexTheV)\n        for(unsigned int u = std::min(u1[t],indexTheV); u < std::max(u2[t],indexTheV) + 1; u++) /////explore colum of states\n        {\n          if(temp_Q > Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty)\n          {\n            temp_Q = Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty;\n            temp_indState = u;\n            temp_chpt = t;\n          }\n        }\n      }\n\n      /////\n      ///// Write response\n      /////\n      lastChpt[v][T] = temp_chpt;\n      lastIndState[v][T] = temp_indState;\n      Q[v][T] = temp_Q;\n    }\n  }\n\n  delete [] u1;\n  u1 = NULL;\n  delete [] u2;\n  u2 = NULL;\n  delete [] S1;\n  S1 = NULL;\n  delete [] S2;\n  S2 = NULL;\n  delete [] SP;\n  SP = NULL;\n}\n\n\n\n//####### algoPruning #######////####### algoPruning #######////####### algoPruning #######//\n//####### algoPruning #######////####### algoPruning #######////####### algoPruning #######//\n//####### algoPruning #######////####### algoPruning #######////####### algoPruning #######//\n//####### algoPruning #######////####### algoPruning #######////####### algoPruning #######//\n//####### algoPruning #######////####### algoPruning #######////####### algoPruning #######//\n\nvoid Omega::algoPruning(std::vector< double >& data)\n{\n  unsigned int n = data.size();\n  unsigned int p = nbStates;\n\n  ///\n  /// PREPROCESSING\n  ///\n  double* S1 = new double[n];\n  double* S2 = new double[n];\n  double* SP = new double[n];\n  S1[0] = data[0];\n  S2[0] = data[0] * data[0];\n  SP[0] = data[0];\n  for(unsigned int i = 1; i < n; i++){S1[i] = S1[i-1] + data[i];}\n  for(unsigned int i = 1; i < n; i++){S2[i] = S2[i-1] + (data[i] * data[i]);}\n  for(unsigned int i = 1; i < n; i++){SP[i] = SP[i-1] + (i+1) * data[i];}\n\n  double* MAX_Y = new double[n];\n  double* MIN_Y = new double[n];\n  MAX_Y[n-1] = 1.0*data[n-2];\n  MIN_Y[n-1] = 1.0*data[n-2];\n  for(int i = n-2; i > -1; i--){MAX_Y[i] = std::max(1.0*data[i], MAX_Y[i+1]);}\n  for(int i = n-2; i > -1; i--){MIN_Y[i] = std::min(1.0*data[i], MIN_Y[i+1]);}\n\n\n  std::list< unsigned int>* t_pos = new std::list< unsigned int>[p];\n  std::list< unsigned int>* u_pos = new std::list< unsigned int>[p];\n  std::list<unsigned int>::iterator t_it;\n  std::list<unsigned int>::iterator u_it;\n\n\n  Costs cost;\n  ///\n  /// FILL FIRST COLUMN in Q\n  ///\n  for(unsigned int i = 0; i < p; i++)\n  {\n    Q[i][0] = (data[0] - states[i])*(data[0] - states[i]);\n    lastChpt[i][0] = 0;\n    lastIndState[i][0] = 0;\n  }\n\n  ///\n  /// ALGO\n  ///\n  double temp_Q = -1;\n  int temp_chpt = -1;\n  unsigned int temp_indState = 0;\n  ///variables for pruning\n  double delta;\n  double DELTA;\n  double K;\n\n  unsigned int Tp1;\n  unsigned int nm1 = n-1;\n  int nbnb = 0;\n  ///\n  /// states u to v -> time position t to T\n  /// explore in (u,t) for fixed (v,T)\n  ///\n  for(unsigned int T = 1; T < n; T++)\n  {\n    for(unsigned int v = 0; v < p; v++)\n    {\n      /////\n      ///// Add last column to explore\n      /////\n      for(unsigned int w = 0; w < p; w++)\n      {\n        u_pos[v].push_back(w);\n        t_pos[v].push_back(T-1);\n      }\n\n      /// FIRST ELEMENT\n      u_it = u_pos[v].begin();\n      t_it = t_pos[v].begin();\n\n      //std::cout << u_pos[v].size() << \" \" << t_pos[v].size() << *u_it << *t_it;\n\n      temp_Q = Q[*u_it][*t_it] + cost.slopeCost(states[*u_it], states[v], *t_it, T, S1[*t_it], S1[T], S2[*t_it], S2[T], SP[*t_it], SP[T]) + penalty;\n      temp_indState = *u_it;\n      temp_chpt = *t_it;\n\n      u_it = u_pos[v].begin();\n      t_it = t_pos[v].begin();\n      while (t_it != t_pos[v].end())\n      {\n        if(temp_Q > Q[*u_it][*t_it] + cost.slopeCost(states[*u_it], states[v], *t_it, T, S1[*t_it], S1[T], S2[*t_it], S2[T], SP[*t_it], SP[T]) + penalty)\n        {\n          temp_Q = Q[*u_it][*t_it] + cost.slopeCost(states[*u_it], states[v], *t_it, T, S1[*t_it], S1[T], S2[*t_it], S2[T], SP[*t_it], SP[T]) + penalty;\n          temp_indState = *u_it;\n          temp_chpt = *t_it;\n        }\n\n        ++u_it;\n        ++t_it;\n      }\n\n      //std::cout << \" end \"<< *u_it << \" \"<< *t_it << std::endl;\n\n      /////\n      ///// Write response\n      /////\n      Q[v][T] = temp_Q;\n      lastIndState[v][T] = temp_indState;\n      lastChpt[v][T] = temp_chpt;\n\n\n      /////\n      ///// PRUNING STEP TO BE DONE\n      /////\n      u_it = u_pos[v].begin();\n      t_it = t_pos[v].begin();\n      while (t_it != t_pos[v].end())\n      {\n        Tp1 = T+1;\n        DELTA = states[*u_it] - states[v];\n        if(DELTA >= 0){delta = MAX_Y[T] - states[v];}else{delta = MIN_Y[T] - states[v];}\n\n        K = SP[T] - SP[*t_it] -  (*t_it + 1) * (S1[T] - S1[*t_it]);\n        //std::cout << \"delta \" << delta << \" DELTA \" << DELTA << \" K \" << K << std::endl;\n\n        if((Q[*u_it][*t_it] + cost.slopeCost(states[*u_it], states[v], *t_it, T, S1[*t_it], S1[T], S2[*t_it], S2[T], SP[*t_it], SP[T]) > temp_Q) && cost.pruningTest(*t_it, T, Tp1, delta, DELTA, K, states[v]) && cost.pruningTest(*t_it, T, nm1, delta, DELTA, K, states[v]))\n          {nbnb =nbnb +1; u_it = u_pos[v].erase(u_it); t_it = t_pos[v].erase(t_it);}else{++u_it; ++t_it;}\n\n      }\n\n    }\n  }\n\n  //std::cout << \"nbnb \" << nbnb << std::endl;\n\n  delete [] S1;\n  S1 = NULL;\n  delete [] S2;\n  S2 = NULL;\n  delete [] SP;\n  SP = NULL;\n  delete [] MAX_Y;\n  MAX_Y = NULL;\n  delete [] MIN_Y;\n  MIN_Y = NULL;\n  delete [] t_pos;\n  t_pos = NULL;\n  delete [] u_pos;\n  u_pos = NULL;\n}\n\n\n//####### backtracking #######////####### backtracking #######////####### backtracking #######//\n//####### backtracking #######////####### backtracking #######////####### backtracking #######//\n//####### backtracking #######////####### backtracking #######////####### backtracking #######//\n//####### backtracking #######////####### backtracking #######////####### backtracking #######//\n//####### backtracking #######////####### backtracking #######////####### backtracking #######//\n\nvoid Omega::backtracking(unsigned int n)\n{\n  unsigned int p = nbStates;\n  double temp_Q = Q[0][n-1];\n  unsigned int temp_indState = 0;\n\n  for(unsigned int v = 1; v < p; v++)\n  {\n    if(Q[v][n-1] < temp_Q)\n    {\n      temp_Q = Q[v][n-1];\n      temp_indState = v;\n    }\n  }\n\n  globalCost = Q[temp_indState][n-1];\n  unsigned int temp_chpt = n-1;\n\n  while(temp_chpt > 0)\n  {\n    changepoints.push_back(temp_chpt);\n    parameters.push_back(states[temp_indState]);\n\n    temp_chpt = lastChpt[temp_indState][temp_chpt];\n    temp_indState = lastIndState[temp_indState][changepoints[changepoints.size()-1]];\n  }\n\n  changepoints.push_back(0);\n  parameters.push_back(states[temp_indState]);\n\n  ///reverse the vector\n  std::reverse(changepoints.begin(), changepoints.end());\n  std::reverse(parameters.begin(), parameters.end());\n\n}\n\n\n\n\n//####### algoChannelUP #######////####### algoChannelUP #######////####### algoChannelUP #######//\n//####### algoChannelUP #######////####### algoChannelUP #######////####### algoChannelUP #######//\n//####### algoChannelUP #######////####### algoChannelUP #######////####### algoChannelUP #######//\n//####### algoChannelUP #######////####### algoChannelUP #######////####### algoChannelUP #######//\n//####### algoChannelUP #######////####### algoChannelUP #######////####### algoChannelUP #######//\n\n\nvoid Omega::algoChannelUP(std::vector< double >& data)\n{\n  unsigned int n = data.size();\n  unsigned int p = nbStates;\n\n  ///\n  /// PREPROCESSING\n  ///\n  double* S1 = new double[n];\n  double* S2 = new double[n];\n  double* SP = new double[n];\n  S1[0] = data[0];\n  S2[0] = data[0] * data[0];\n  SP[0] = data[0] ;\n  for(unsigned int i = 1; i < n; i++){S1[i] = S1[i-1] + data[i];}\n  for(unsigned int i = 1; i < n; i++){S2[i] = S2[i-1] + (data[i] * data[i]);}\n  for(unsigned int i = 1; i < n; i++){SP[i] = SP[i-1] + (i+1) * data[i];}\n\n  Costs cost;\n  ///\n  /// FILL FIRST COLUMN in Q\n  ///\n  for(unsigned int i = 0; i < p; i++)\n  {\n    Q[i][0] = (data[0] - states[i])*(data[0] - states[i]);\n    lastIndState[i][0] = 0;\n    lastChpt[i][0] = 0;\n  }\n\n  ///\n  /// ALGO\n  ///\n  double temp_Q = -1;\n  int temp_chpt = -1;\n  unsigned int temp_indState = 0;\n\n  //////////////////////////////////////////////////\n  //////////////////////////////////////////////////\n  ///\n  /// CHANNEL INFORMATION\n  /// u1 / u2 = \"min / max\" in each column of Q\n  ///\n  unsigned int* u1 = new unsigned int[n];\n  unsigned int* u2 = new unsigned int[n];\n  unsigned int theStart;\n  unsigned int theEnd;\n  double theV = 0;\n  unsigned int indexTheV = 0;\n\n  unsigned int zero = 0;\n  ///\n  /// states u to v -> time position t to T\n  /// explore in (u,t) for fixed (v,T)\n  ///\n  for(unsigned int T = 1; T < n; T++)\n  {\n    ///\n    /// FILL u1 and u2 vectors\n    ///\n    theStart = 0;\n    while(theStart < (p - 1) && Q[theStart][T - 1] > Q[theStart + 1][T - 1]){theStart = theStart + 1;}\n    u1[T-1] = theStart;\n    theEnd = p - 1;\n    while(theEnd > 0 && Q[theEnd][T - 1] > Q[theEnd - 1][T - 1]){theEnd = theEnd - 1;}\n    u2[T-1] = theEnd;\n\n\n    for(unsigned int v = 0; v < p; v++)\n    {\n      /////\n      ///// EXPLORE MATRIX size p*T -> restricted on each column\n      /////\n      temp_Q = Q[0][0] + cost.slopeCost(states[0], states[v], zero, T, S1[0], S1[T], S2[0], S2[T], SP[0], SP[T]) + penalty;\n      temp_indState = 0;\n      temp_chpt = 0;\n\n      for(unsigned int t = 0; t < T; t++)\n      {\n        /////\n        ///// FIND the minimum of the cost in start state\n        /////\n        if(t < T-1){\n          theV = cost.vhat(states[v], t, T, S1[t], S1[T], SP[t], SP[T]);\n          indexTheV = cost.closestState(theV, states, p);\n        }else{indexTheV = u1[T-1];}\n\n        ///\n        /// explore values between min(u1[t],indexTheV) and max(u2[t],indexTheV) + MIN with v\n        ///\n        for(unsigned int u = std::min(std::min(u1[t],indexTheV), v); u < std::min(std::max(u2[t],indexTheV), v) + 1; u++) /////explore colum of states\n        {\n          if(temp_Q > Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty)\n          {\n            temp_Q = Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty;\n            temp_indState = u;\n            temp_chpt = t;\n          }\n        }\n      }\n\n      /////\n      ///// Write response\n      /////\n      lastChpt[v][T] = temp_chpt;\n      lastIndState[v][T] = temp_indState;\n      Q[v][T] = temp_Q;\n    }\n  }\n\n  delete [] u1;\n  u1 = NULL;\n  delete [] u2;\n  u2 = NULL;\n  delete [] S1;\n  S1 = NULL;\n  delete [] S2;\n  S2 = NULL;\n  delete [] SP;\n  SP = NULL;\n}\n\n\n\n\n//####### algoUPDOWN #######////####### algoUPDOWN #######////####### algoUPDOWN #######//\n//####### algoUPDOWN #######////####### algoUPDOWN #######////####### algoUPDOWN #######//\n//####### algoUPDOWN #######////####### algoUPDOWN #######////####### algoUPDOWN #######//\n//####### algoUPDOWN #######////####### algoUPDOWN #######////####### algoUPDOWN #######//\n//####### algoUPDOWN #######////####### algoUPDOWN #######////####### algoUPDOWN #######//\n\nvoid Omega::algoUPDOWM(std::vector< double >& data)\n{\n  unsigned int n = data.size();\n  unsigned int p = nbStates;\n\n  ///\n  /// PREPROCESSING\n  ///\n  double* S1 = new double[n];\n  double* S2 = new double[n];\n  double* SP = new double[n];\n  S1[0] = data[0];\n  S2[0] = data[0] * data[0];\n  SP[0] = data[0] ;\n  for(unsigned int i = 1; i < n; i++){S1[i] = S1[i-1] + data[i];}\n  for(unsigned int i = 1; i < n; i++){S2[i] = S2[i-1] + (data[i] * data[i]);}\n  for(unsigned int i = 1; i < n; i++){SP[i] = SP[i-1] + (i+1) * data[i];}\n\n  int** SLOPE = new int*[p];\n  for(unsigned int i = 0; i < p; i++){SLOPE[i] = new int[n];}\n\n  Costs cost;\n  ///\n  /// FILL FIRST COLUMN in Q\n  ///\n  for(unsigned int i = 0; i < p; i++)\n  {\n    Q[i][0] = (data[0] - states[i])*(data[0] - states[i]);\n    lastChpt[i][0] = 0;\n    lastIndState[i][0] = 0;\n    SLOPE[i][0] = 0;\n  }\n\n  ///\n  /// ALGO\n  ///\n  double temp_Q = -1;\n  int temp_chpt = -1;\n  unsigned int temp_indState = 0;\n\n  ///\n  /// states u to v -> time position t to T\n  /// explore in (u,t) for fixed (v,T)\n  ///\n\n\n  for(unsigned int T = 1; T < n; T++)\n  {\n    for(unsigned int v = 0; v < p; v++)\n    {\n      /////\n      ///// EXPLORE MATRIX size p*T\n      /////\n      temp_Q = INFINITY;\n      temp_indState = 0;\n      temp_chpt = 0;\n\n      for(unsigned int t = 0; t < T; t++)\n      {\n        for(unsigned int u = 0; u < p; u++) /////explore colum of states\n        {\n          if(!(u < v && SLOPE[u][t] == -1))\n          {\n            if(temp_Q > Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty)\n            {\n              temp_Q = Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty;\n              temp_indState = u;\n              temp_chpt = t;\n            }\n          }\n        }\n\n      }\n      /////\n      ///// Write response\n      /////\n      Q[v][T] = temp_Q;\n      lastIndState[v][T] = temp_indState;\n      lastChpt[v][T] = temp_chpt;\n\n      if(temp_indState > v){SLOPE[v][T] = -1;}\n      if(temp_indState < v){SLOPE[v][T] = 1;}\n      if(temp_indState == v){if(SLOPE[temp_indState][temp_chpt] == -1){SLOPE[v][T] = -1;}}\n    }\n  }\n\n  delete [] S1;\n  S1 = NULL;\n  delete [] S2;\n  S2 = NULL;\n  delete [] SP;\n  SP = NULL;\n\n  for(unsigned int i = 0; i < p; i++){delete(SLOPE[i]);}\n  delete [] SLOPE;\n  SLOPE = NULL;\n\n}\n\n\n\n\n\n//####### algoOUTLIER #######////####### algoOUTLIER #######////####### algoOUTLIER #######//\n//####### algoOUTLIER #######////####### algoOUTLIER #######////####### algoOUTLIER #######//\n//####### algoOUTLIER #######////####### algoOUTLIER #######////####### algoOUTLIER #######//\n//####### algoOUTLIER #######////####### algoOUTLIER #######////####### algoOUTLIER #######//\n//####### algoOUTLIER #######////####### algoOUTLIER #######////####### algoOUTLIER #######//\n\nvoid Omega::algoSMOOTHING(std::vector< double >& data, double minAngle)\n{\n  unsigned int n = data.size();\n  unsigned int p = nbStates;\n\n  ///\n  /// PREPROCESSING\n  ///\n  double* S1 = new double[n];\n  double* S2 = new double[n];\n  double* SP = new double[n];\n  S1[0] = data[0];\n  S2[0] = data[0] * data[0];\n  SP[0] = data[0] ;\n  for(unsigned int i = 1; i < n; i++){S1[i] = S1[i-1] + data[i];}\n  for(unsigned int i = 1; i < n; i++){S2[i] = S2[i-1] + (data[i] * data[i]);}\n  for(unsigned int i = 1; i < n; i++){SP[i] = SP[i-1] + (i+1) * data[i];}\n\n  Costs cost;\n  ///\n  /// FILL FIRST COLUMN in Q\n  ///\n  for(unsigned int i = 0; i < p; i++)\n  {\n    Q[i][0] = (data[0] - states[i])*(data[0] - states[i]);\n    lastChpt[i][0] = 0;\n    lastIndState[i][0] = i;\n  }\n\n  ///\n  /// ALGO\n  ///\n  double temp_Q = -1;\n  int temp_chpt = -1;\n  unsigned int temp_indState = 0;\n\n  ///\n  /// states u to v -> time position t to T\n  /// explore in (u,t) for fixed (v,T)\n  ///\n  //std::cout << \"minAngle \" << minAngle << std::endl;\n\n  for(unsigned int T = 1; T < n; T++)\n  {\n    for(unsigned int v = 0; v < p; v++)\n    {\n      /////\n      ///// EXPLORE MATRIX size p*T\n      /////\n      temp_Q = INFINITY;\n      temp_indState = 0;\n      temp_chpt = 0;\n\n      for(unsigned int t = 0; t < T; t++)\n      {\n        for(unsigned int u = 0; u < p; u++) /////explore colum of states\n        {\n          //std::cout << \"-- \" << lastChpt[u][t] << \" -- \";\n          if(cost.angleTest(lastChpt[u][t], t, T, states[lastIndState[u][t]], states[u], states[v], minAngle))\n          {\n            if(temp_Q > Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty)\n            {\n              temp_Q = Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty;\n              temp_indState = u;\n              temp_chpt = t;\n            }\n          }\n        }\n\n\n      }\n      /////\n      ///// Write response\n      /////\n      Q[v][T] = temp_Q;\n      lastIndState[v][T] = temp_indState;\n      lastChpt[v][T] = temp_chpt;\n\n    }\n  }\n\n  delete [] S1;\n  S1 = NULL;\n  delete [] S2;\n  S2 = NULL;\n  delete [] SP;\n  SP = NULL;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//####### algoPruning2 #######////####### algoPruning2 #######////####### algoPruning2 #######//\n//####### algoPruning2 #######////####### algoPruning2 #######////####### algoPruning2 #######//\n//####### algoPruning2 #######////####### algoPruning2 #######////####### algoPruning2 #######//\n//####### algoPruning2 #######////####### algoPruning2 #######////####### algoPruning2 #######//\n//####### algoPruning2 #######////####### algoPruning2 #######////####### algoPruning2 #######//\n\nvoid Omega::algoPruning2(std::vector< double >& data)\n{\n  unsigned int n = data.size();\n  unsigned int p = nbStates;\n\n  ///\n  /// PREPROCESSING\n  ///\n  double* S1 = new double[n];\n  double* S2 = new double[n];\n  double* SP = new double[n];\n  S1[0] = data[0];\n  S2[0] = data[0] * data[0];\n  SP[0] = data[0];\n  for(unsigned int i = 1; i < n; i++){S1[i] = S1[i-1] + data[i];}\n  for(unsigned int i = 1; i < n; i++){S2[i] = S2[i-1] + (data[i] * data[i]);}\n  for(unsigned int i = 1; i < n; i++){SP[i] = SP[i-1] + (i+1) * data[i];}\n\n  double* S1decay = new double[n];\n  S1decay[0] = 0;\n  for(unsigned int i = 1; i < n; i++){S1decay[i] = S1decay[i-1] + data[i-1];} //cumsum from 0, y_1,...\n\n  double* MAX_Y = new double[n]; //new type of max\n  double* MIN_Y = new double[n]; //new type of min\n  for(unsigned int i = 0; i < n; i++)\n  {\n    MAX_Y[i] = 1.0*data[i];\n    MIN_Y[i] = 1.0*data[i];\n  }\n\n  for(unsigned int i = 0; i < n-1; i++)\n  {\n    for(unsigned int j = i + 1; j < n-1; j++)\n    {\n      MAX_Y[i] = std::max(S1decay[j+1] - S1decay[i], MAX_Y[i]);\n      MIN_Y[i] = std::min(S1decay[j+1] - S1decay[i], MIN_Y[i]);\n    }\n  }\n\n\n  Costs cost;\n  ///\n  /// FILL FIRST COLUMN in Q\n  ///\n  for(unsigned int i = 0; i < p; i++)\n  {\n    Q[i][0] = (data[0] - states[i])*(data[0] - states[i]);\n    lastChpt[i][0] = 0;\n    lastIndState[i][0] = 0;\n  }\n\n  ///\n  /// ALGO\n  ///\n  double temp_Q = -1;\n  unsigned int temp_chpt = 0;\n  unsigned int temp_indState = 0;\n  ///variables for pruning\n  //double delta;\n  //double DELTA;\n  //double K;\n\n  //unsigned int Tp1;\n  //unsigned int nm1 = n-1;\n\n  //int nbnb = 0;\n  ///\n  /// states u to v -> time position t to T\n  /// explore in (u,t) for fixed (v,T)\n  ///\n\n  ListPoint* myList = new ListPoint[p];\n  for(unsigned int q = 0; q < p; q++)\n  {\n    myList[q] = ListPoint(); ///danger. Add elements\n  }\n\n  bool test = true;\n  unsigned int t;\n  unsigned int u;\n\n\n  for(unsigned int T = 1; T < n; T++)\n  {\n    for(unsigned int v = 0; v < p; v++)\n    {\n\n      /////\n      ///// Add last column to explore\n      /////\n      for(unsigned int w = 0; w < p; w++)\n      {\n        myList[v].addPoint(new Point(w, T-1));\n      }\n\n      /// FIRST ELEMENT\n      myList[v].initializeCurrentPosition();\n      u = myList[v].getState();\n      t = myList[v].getTime();\n\n      temp_Q = Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty;\n      temp_indState = u;\n      temp_chpt = t;\n      test = myList[v].move();\n\n      while(test == true)\n      {\n        u = myList[v].getState();\n        t = myList[v].getTime();\n        if(temp_Q > Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty)\n        {\n          temp_Q = Q[u][t] + cost.slopeCost(states[u], states[v], t, T, S1[t], S1[T], S2[t], S2[T], SP[t], SP[T]) + penalty;\n          temp_indState = u;\n          temp_chpt = t;\n        }\n        test = myList[v].move();\n\n      }\n\n      /////\n      ///// Write response\n      /////\n      Q[v][T] = temp_Q;\n      lastIndState[v][T] = temp_indState;\n      lastChpt[v][T] = temp_chpt;\n\n\n      ////////////////////////\n      ///// PRUNING STEP /////\n      ////////////////////////\n      //u_it = u_pos[v].begin();\n      //t_it = t_pos[v].begin();\n      //while (t_it != t_pos[v].end())\n      //{\n      //  Tp1 = T+1;\n      //  DELTA = states[*u_it] - states[v];\n      //  if(DELTA >= 0){delta = 2*MAX_Y[T] - states[v];}else{delta = 2*MIN_Y[T] - states[v];}\n      //  delta = delta/((T-*t_it)*(T-*t_it-1));\n      //  K = SP[T] - SP[*t_it] -  (*t_it + 1) * (S1[T] - S1[*t_it]);\n        //std::cout << \"delta \" << delta << \" DELTA \" << DELTA << \" K \" << K << std::endl;\n\n        //    if((Q[*u_it][*t_it] + cost.slopeCost(states[*u_it], states[v], *t_it, T, S1[*t_it], S1[T], S2[*t_it], S2[T], SP[*t_it], SP[T]) > temp_Q) && cost.pruningTest(*t_it, T, Tp1, delta, DELTA, K, states[v]) && cost.pruningTest(*t_it, T, nm1, delta, DELTA, K, states[v]))\n        //    {nbnb = nbnb +1;u_it = u_pos[v].erase(u_it); t_it = t_pos[v].erase(t_it);}else{++u_it; ++t_it;}\n\n        //  ++u_it; ++t_it;\n        //}\n    }\n  }\n\n  //std::cout << \"nbnb \" << nbnb << std::endl;\n\n  delete [] S1decay;\n  S1decay = NULL;\n  delete [] S1;\n  S1 = NULL;\n  delete [] S2;\n  S2 = NULL;\n  delete [] SP;\n  SP = NULL;\n  delete [] MAX_Y;\n  MAX_Y = NULL;\n  delete [] MIN_Y;\n  MIN_Y = NULL;\n  delete [] myList;\n  myList = NULL;\n}\n\n",
    "created" : 1561361635193.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "412763383",
    "id" : "B2804E81",
    "lastKnownWriteTime" : 1562831224,
    "last_content_update" : 1562831224663,
    "path" : "C:/slopeOP/src/Omega.cpp",
    "project_path" : "src/Omega.cpp",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}