{
    "collab_server" : "",
    "contents" : "\n#' slopeOP\n#' @description Optimal partitioning algorithm for change-in-slope problem with a finite number of states (beginning and ending values of each segment is restricted to a finite set of values).\n#' The algorithm takes into account a continuity constraint between successive segments and infers a continuous piecewise linear signal\n#' @param data vector of data to segment\n#' @param states vector of states = set of accessible starting/ending values for segments in increasing order\n#' @param penalty the penalty value (a positive number)\n#' @param constraint string defining a constraint : \"null\", \"up\", \"updown\" or \"smoothing\"\n#' @param minAngle a minimal inner angle in degree between consecutive segments in case constraint = \"smoothing\"\n#' @param type string defining the pruning type to use. \"null\" = no pruning, \"channel\" = use monotonicity property or \"pruning\" = pelt-type property\n#' @param testMode a boolean, if true the function also returns the percent of elements to scan (= ratio number scanned elements vs. scanned elements if no pruning)\n#' @return a list of three elements  = (changepoints, state parameters, global cost)\n#' 'changepoints' is the vector of changepoints (we give the extremal values of all segments from left to right)\n#' 'states' is the vector of successive states. states[i] is the value we infered at position changepoints[i]\n#' 'globalCost' is a number equal to the global cost of the penalized changepoint problem\n#' 'pruning' is the reduction of work for the algo vs. no pruned algo\nslopeOP <- function(data = c(0), states = c(0), penalty = 0, constraint = \"null\", minAngle = 0, type = \"channel\", testMode = FALSE)\n{\n  ############\n  ### STOP ###\n  ############\n  if(!is.numeric(data)){stop('data values are not all numeric')}\n  if(!is.numeric(states)){stop('states are not all numeric')}\n  if(is.unsorted(states)){stop('states should be an increasing vector')}\n  if(!is.double(penalty)){stop('penalty is not a double.')}\n  if(penalty < 0){stop('penalty must be nonnegative')}\n  if(!is.double(minAngle)){stop('minAngle is not a double.')}\n  if(minAngle < 0 || minAngle > 180){stop('minAngle must lie between 0 and 180')}\n\n  if(constraint != \"null\" && constraint != \"up\" && constraint != \"updown\" && constraint != \"smoothing\")\n    {stop('Arugment \"constraint\" not appropriate. Choose among \"null\", \"up\", \"down\" and \"smoothing\"')}\n  if(type != \"null\" && type != \"channel\" && type != \"pruning\" && type != \"pruning2\")\n    {stop('Arugment \"type\" not appropriate. Choose among \"null\", \"channel\" and \"pruning\"')}\n\n  if(!is.logical(testMode)){stop('testMode must be a boolean')}\n\n  ###CALL Rcpp functions###\n  res <- slopeOPtransfer(data, states, penalty, constraint, minAngle, type)\n\n  ###Response class slopeOP###\n  if(testMode == FALSE){response <- list(changepoints = res$changepoints + 1, parameters = res$parameters, globalCost = res$globalCost - penalty)}\n  if(testMode == TRUE){response <- list(changepoints = res$changepoints + 1, parameters = res$parameters, globalCost = res$globalCost - penalty, pruning = res$pruningPower)}\n\n  attr(response, \"class\") <- \"slopeOP\"\n\n  return(response)\n}\n\n\n\n\n#' slopeData\n#' @description Generate data with a given continuous piecewise linear model\n#' @param index a vector of increasing changepoint indexes\n#' @param states vector of successive states\n#' @param noise noise level = standard deviation of an additional normal noise\n#' @return a vector of simulated data\nslopeData <- function(index = c(0), states = c(0), noise = 0)\n{\n  ############\n  ### STOP ###\n  ############\n  if(!is.numeric(index)){stop('data values are not all numeric')}\n  if(is.unsorted(index)){stop('index should be an increasing vector')}\n  if(!is.numeric(states)){stop('states are not all numeric')}\n  if(length(index) != length(states)){stop('index and states vectors are of different size')}\n  if(!is.double(noise)){stop('noise is not a double.')}\n  if(noise < 0){stop('noise must be nonnegative')}\n\n  steps <- diff(states)/diff(index)\n  response <- rep(steps,diff(index))\n  response <- c(states[1],cumsum(response)+ states[1])\n  response <- response + rnorm(length(response),0, noise)\n\n  return(response)\n}\n\n\n\n\n",
    "created" : 1561449915983.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3125504671",
    "id" : "83E715E6",
    "lastKnownWriteTime" : 1562830966,
    "last_content_update" : 1562830966495,
    "path" : "C:/slopeOP/R/slopeOP.R",
    "project_path" : "R/slopeOP.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}