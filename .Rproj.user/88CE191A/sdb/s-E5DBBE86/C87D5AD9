{
    "collab_server" : "",
    "contents" : "// MIT License\n// Copyright (c) 2019 Marco Pascucci\n\n#include <vector>\n#include <iostream>\n#include <assert.h>\n\nusing namespace std;\n\ntemplate<typename T>\nvoid printv(vector<T> vector) {\n    cout << \"[ \";\n    for (size_t i = 0; i<vector.size(); i++) {\n        cout << vector[i];\n        if (i!=vector.size()-1) cout << \", \";\n    }\n    cout << \" ]\" << endl;\n}\n\ntemplate<class T>\nvector<T> range(int start, int end) {\n    if(start > end){\n        throw std::invalid_argument( \"start > end\" );\n    }\n    vector<T> out(end-start);\n    for (size_t i=0; i<end-start; i++) {\n        out[i] = i+start;\n    }\n    return out;\n}\n\ntemplate<class T>\nvector<T> range(int end) {\n    return range<T>(0,end);\n}\n\ntemplate<class T>\nvoid range(vector<T> &v) {\n    for (typename vector<T>::size_type i=0; i < v.size(); i++) {\n        v[i] = i;\n    }\n}\n\n\n// template<typename T1, typename T2>\n// double dot(vector<T1> &a, vector<T2> &b, size_t start, size_t end) {\n//     if(a.size() != b.size()){\n//         throw std::invalid_argument( \"a and b must have the same dimension\" );\n//     }\n//     if(start < 0 || end > a.size() ){\n//         throw std::invalid_argument( \"invalid start/end range\" );\n//     }\n//     double sum = 0;\n//     for (size_t i=start; i< end; i++) {\n//         sum = sum + a[i]*b[i];\n//     }\n//     return sum;\n// }\n// template<typename T1, typename T2>\n// double dot(vector<T1> &a, vector<T2> &b) {\n//     return dot(a, b, 0, a.size());\n// }\n//  //specialization to return int\n// int dot(vector<int> &a, vector<int> &b, size_t start, size_t end);\n// int dot(vector<int> &a, vector<int> &b);\n\n\n// template<class T>\n// T accumulate(vector<T> &v, size_t start, size_t end) {\n//     if(start < 0 || end > v.size() ){\n//         throw std::invalid_argument( \"invalid start/end range\" );\n//     }\n//     T sum = 0;\n//     for (typename vector<T>::size_type i=start; i<end; i++) {\n//         sum = sum + v[i];\n//     }\n//     return sum;\n// }\n// template<class T>\n// T accumulate(vector<T> &v) {\n//     return accumulate(v, 0, v.size());\n// }\n\n\ntemplate<typename T1, typename T2>\nvoid lin_reg_no_const(vector<T1> &x, vector<T2> &y, double *coeff, size_t start, size_t end){\n    *coeff = 1.0/(inner_product(x.begin()+start,x.begin()+end,x.begin()+start,0.0))*\n             inner_product(x.begin()+start,x.begin()+end,y.begin()+start,0.0);\n}\n\ntemplate<typename T1, typename T2>\nvoid lin_reg(vector<T1> &x, vector<T2> &y, double *coeff, double *intercept, size_t start, size_t end){\n    /* calculate LSLR on x,y from position start to end (excluded). */\n\n    assert(y.size() == x.size());\n    assert(start >= 0 && end <= x.size());\n\n    double m00, m11, m01, det;\n    double i00, i11, i01;\n\n    m00 = end-start;\n    m11 = inner_product(x.begin()+start,x.begin()+end,x.begin()+start,0.0);\n    m01 = accumulate(x.begin()+start,x.begin()+end,0.0);\n\n    det = (m00*m11)-m01*m01;\n\n    i00 = m11/det;\n    i11 = m00/det;\n    i01 = -m01/det;\n\n    double v1 = accumulate(y.begin()+start,y.begin()+end,0.0);\n    double v2 = inner_product(x.begin()+start,x.begin()+end,y.begin()+start,0.0);\n\n    *intercept = i00*v1 + i01*v2;\n    *coeff = i01*v1 + i11*v2;\n}\n\ntemplate<typename T1, typename T2>\nvoid lin_reg(vector<T1> &x, vector<T2> &y, double *coeff, double *intercept){\n    return lin_reg(x, y, coeff, intercept, 0, x.size());\n}\ntemplate<typename T1, typename T2>\nvoid lin_reg_no_const(vector<T1> &x, vector<T2> &y, double *coeff){\n    return lin_reg_no_const(x, y, coeff, 0, x.size());\n}\n\n\n\ntemplate<typename T>\nvector<double> line(const vector<T> &x,\n                    const double coeff,\n                    size_t start,\n                    size_t end,\n                    const double inter=0) {\n    /* calculate a linear segment, given a vector x, and the line coefficients\n     * from start to end (excluded)\n     */\n\n    if(start < 0 || end > x.size() ){\n        throw std::invalid_argument( \"invalid start/end range\" );\n    }\n    vector<double> y(end-start);\n    for (size_t i=start; i<end; i++) {\n        y[i] = coeff*x[i] + inter;\n    }\n    return y;\n}\ntemplate<typename T>\nvector<double> line(const vector<T> &x, const double coeff, const double inter=0) {\n    return line(x, coeff, 0, x.size(), inter);\n}\n",
    "created" : 1562834958179.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1448891182",
    "id" : "C87D5AD9",
    "lastKnownWriteTime" : 1561361549,
    "last_content_update" : 1561361549,
    "path" : "C:/slopeOP/src/linalg.h",
    "project_path" : "src/linalg.h",
    "properties" : {
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "h"
}